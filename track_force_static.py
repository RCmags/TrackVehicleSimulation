# Program Description: 
# Simulate a tracked vehicle undergoing various control inputs.
 
#================= Libraries =================
import math
import numpy as np
import matplotlib.pylab as plt
import matplotlib.animation as animation
import matplotlib.patches as patches
import matplotlib as mpl


#================= Constants =================

    #Time
TIME_INIT   = 0
TIME_LAST   = 85
STEPS       = 5000
DT          = (TIME_LAST - TIME_INIT)/STEPS

    #Plot
AXIS_LIMIT  = 5

    #Dimensions
WIDTH       = 0.2
LENGTH      = 1.0
BASE        = 0.5
ARROW_WIDTH = 0.2

    #Inertial parameters
MASS        = 1.0
INERTIA     = 1.0

    #Friction
VEL_STAT    = 0.05
U_STAT      = 1
U_DYN       = 1
K_STAT      = 2
NUM_X       = 2
NUM_Y       = 10

    #Gravity acceleration
ANG_XY      = 0 
ANG_RZ      = -30
GRAVITY     = 1
            #
ANG_XY     *= math.pi/180.0
ANG_RZ     *= math.pi/180.0
GRAV_XY     = math.sin( ANG_RZ ) * GRAVITY
GRAV_X      = math.cos( ANG_XY ) * GRAV_XY
GRAV_Y      = math.sin( ANG_XY ) * GRAV_XY
GRAV_Z      = math.cos( ANG_RZ ) * GRAVITY
F_NORM      = GRAV_Z * MASS


#================= Simulation =================

#-- Friction Force [with static friction] acting on a contact element
class fricForce:
    
    def __init__( self, dt, vel_stat, k_stat, u_stat, u_dyn ):
        # Variables
        self.ds         = [0,0]
        #Constants
        self.DT         = dt
        self.VEL_STAT   = vel_stat
        self.K_STAT     = k_stat
        self.U_STAT     = u_stat
        self.U_DYN      = u_dyn

    def vecMag( self, v ):
        return ( v[0]*v[0] + v[1]*v[1] )**0.5

    def update( self, dv, dn ):

        # Normalize velocity
        dv[0] /= self.VEL_STAT
        dv[1] /= self.VEL_STAT
        dv_mag = self.vecMag( dv )

        # Initialize coefficient        
        du = [0,0]

        # Static region:
        if dv_mag <= 1:

            # Displacement [ Trapezoidal integration ]
            self.ds[0] += dv[0] * self.DT
            self.ds[1] += dv[1] * self.DT

            # Friction coefficient
            du[0] = self.ds[0]*self.K_STAT + dv[0]
            du[1] = self.ds[1]*self.K_STAT + dv[1]

                # Limit coefficient
            du_mag = self.vecMag( du )   
            
            if du_mag > 1:
                du[0] = ( du[0]/du_mag )*self.U_STAT
                du[1] = ( du[1]/du_mag )*self.U_STAT

                # Limit displacement
            ds_mag = self.vecMag( self.ds )
            
            if ds_mag > 1:
                self.ds[0] = ( self.ds[0]/ds_mag )*self.U_STAT
                self.ds[1] = ( self.ds[1]/ds_mag )*self.U_STAT

        # Dynamic region:
        else:
            du[0] = ( dv[0]/dv_mag ) * self.U_DYN
            du[1] = ( dv[1]/dv_mag ) * self.U_DYN

            # Reset displacement
            self.ds = [0,0]
        
        # Output Force
        return [ -du[0]*dn, -du[1]*dn ]

		
#-- Net force and torque generated by a track [Region of infinitesimal contact elements]
class trackForce:
    
    def __init__(self, nx, ny, xlen, ylen, dt, vel_stat, k_stat, u_stat, u_dyn ):
        #-- Constants:
        self.NUM_X  = nx
        self.NUM_Y  = ny

        # Bi-directional integration
        nx         *= 2
        ny         *= 2

        # Check dimension size:

            # X-axis
        if nx > 0:
            self.DX = xlen/nx
            nx *= 3
        else:
            self.DX = 0
            nx = 1

            # Y-axis    
        if ny > 0:
            self.DY = ylen/ny
            ny *= 3
        else:
            self.DY = 0
            ny = 1

        # Define scalar
        self.COUNT  = 1/( nx*ny )

        #-- Friction elements:
        self.force = []

        # Scan x-axis
        for x in range( 0, nx + 1 ):
            force_y = []
            
            # Scan y-axis
            for y in range( 0, ny + 1 ):
                force_y.append( fricForce( dt, vel_stat, k_stat, u_stat, u_dyn ) )                     
            #
            self.force.append( force_y )

    def __forceFunc( self, nx, ny, vx, vy, wz ):
        # Position
        y = self.DY * ny 
        x = self.DX * nx

        # Velocity at point
        dv = [ vx - wz*y, vy + wz*x ]

        # Forces at point
        [dfx, dfy] = self.force[nx][ny].update( dv, F_NORM )

        dtz = dfy*x - dfx*y
        return [dfx, dfy, dtz]
    

    def update( self, vx, vy, wz ):
        #- Integrate about x:  

        # Row integral values
        sx = []
        sy = []
        st = []

        for y in range( -self.NUM_Y, self.NUM_Y + 1, 1 ):
            # Initialize rows
            fx = 0
            fy = 0
            tz = 0

            # Apply Simpson's rule:

                # Midpoints
            for x in range( -self.NUM_X + 1, self.NUM_X, 2 ):
                [dfx, dfy, dtz] = self.__forceFunc( x, y, vx, vy, wz )
                fx += 4*dfx
                fy += 4*dfy
                tz += 4*dtz   
            #
                # Subinterval bounds
            for x in range( -self.NUM_X + 2, self.NUM_X - 1, 2 ):
                [dfx, dfy, dtz] = self.__forceFunc( x, y, vx, vy, wz )
                fx += 2*dfx
                fy += 2*dfy
                tz += 2*dtz
            #
                #Bounds
            [dfx_a, dfy_a, dtz_a] = self.__forceFunc( -self.NUM_X, y, vx, vy, wz )
            [dfx_b, dfy_b, dtz_b] = self.__forceFunc( self.NUM_X, y, vx, vy, wz )
            
            fx += dfx_a + dfx_b
            fy += dfy_a + dfy_b
            tz += dtz_a + dtz_b
            
            # Store values
            sx.append( fx )
            sy.append( fy )
            st.append( tz )
        
        #- Integrate about y:
        fx = 0
        fy = 0
        tz = 0

        # Apply Simpson's rule:
        ny = 2*self.NUM_Y

            # Midpoints
        for y in range( 1, ny, 2 ):
            fx += 4*sx[y]
            fy += 4*sy[y]
            tz += 4*st[y]
        
             # Subinterval bounds   
        for y in range( 2, ny - 1, 2 ):
            fx += 2*sx[y]
            fy += 2*sy[y]
            tz += 2*st[y]

        # Scale
        fx = ( fx + sx[0] + sx[ny] )*self.COUNT
        fy = ( fy + sy[0] + sy[ny] )*self.COUNT
        tz = ( tz + st[0] + st[ny] )*self.COUNT
		#
        return [fx, fy, tz]        
    

   #--Class instances:
trkL = trackForce( NUM_X, NUM_Y, WIDTH, LENGTH, DT, VEL_STAT, K_STAT, U_STAT, U_DYN )
trkR = trackForce( NUM_X, NUM_Y, WIDTH, LENGTH, DT, VEL_STAT, K_STAT, U_STAT, U_DYN )


#---- Integrate acceleration and velocity:

    #Control inputs [with respect to time parameter]
def inputVel( t ):
    vel_L = 0
	vel_R = 0
    
    if t < 6:
        vel_L = 0.1
        vel_R = -0.1
    elif t < 20:
        vel_L = 0.2
        vel_R = 0.2
    elif t < 23.5:
        vel_L = 0.2
        vel_R = -0.2
    elif t < TIME_LAST:
        vel_L = 0.8
        vel_R = 0.4
    #
    return [vel_L, vel_R]


def solveMotion():
    #Initialize state:
    x   = []
    y   = []
    ang = []

        #Rotation
    wz      = 0.0
    theta   = 0.0

        #Translation
    accel   = [0,0]
    vel     = [0,0]
    pos     = [0,0]

        #Past values
    tz_1    = 0.0
    wz_1    = 0.0
    accel_1 = [0,0]
    vel_1   = [0,0]    

        #Time
    time = np.linspace( TIME_INIT, TIME_LAST, STEPS )

        #Solve system
    for t in time:

        #Coordinate transform
        sin = math.sin( theta )
        cos = math.cos( theta )

        #Local velocity - track centers
            #Convert global vel to local
        vx = cos*vel[0] + sin*vel[1]
        vy = cos*vel[1] - sin*vel[0]

            #Rigid body track velocities

            #- Input velocities 
        v_input = inputVel(t)

            #- Local velocities
        vx_L = vx
        vy_L = vy - wz*BASE/2 - v_input[0]

        vx_R = vx
        vy_R = vy + wz*BASE/2 - v_input[1]

        #Net forces per track - local frame
        trackL = trkL.update( vx_L, vy_L, wz )
        trackR = trkR.update( vx_R, vy_R, wz )

        fx = trackL[0] + trackR[0]
        fy = trackL[1] + trackR[1]
            #   Track rotation torque            Thrust torque
        tz = ( trackL[2] + trackR[2] ) + ( trackR[1] - trackL[1] )*BASE

        #Integrate forces:
            #Convert local force to global axes
        accel[0] = ( fx*cos - fy*sin )/MASS + GRAV_X
        accel[1] = ( fy*cos + fx*sin )/MASS + GRAV_Y

            #X axis
        vel[0] += 0.5*( accel[0] + accel_1[0] )*DT
        pos[0] += 0.5*( vel[0] + vel_1[0] )*DT
            #Y axis
        vel[1] += 0.5*( accel[1] + accel_1[1] )*DT
        pos[1] += 0.5*( vel[1] + vel_1[1] )*DT
            #Z axis
        wz += ( 0.5*( tz + tz_1 )/INERTIA )*DT
        theta += 0.5*( wz + wz_1 )*DT

        #Update past values
        tz_1 = tz
        wz_1 = wz
        
        accel_1[0] = accel[0]
        accel_1[1] = accel[1]
        vel_1[0] = vel[0]
        vel_1[1] = vel[1]

        #Store values
        x.append( pos[0] )
        y.append( pos[1] )
        ang.append( theta )
    #
	return [x, y, ang]

[x, y, ang] = solveMotion()


#================= Animation =================

#-- Plot and background
fig = plt.figure()
axes = plt.axes()

axes.axis( "scaled" )
axes.set_xlim( -AXIS_LIMIT, AXIS_LIMIT )
axes.set_ylim( -AXIS_LIMIT, AXIS_LIMIT )

    #Add trajectory
scatter = plt.scatter( x[0:STEPS:100],
                       y[0:STEPS:100],
                       c = 'b',
                       marker = 'o',
                       alpha = 0.1,
                       )


#-- Figure components
body = patches.Rectangle(   ( -BASE/2 , -BASE/2 ),
                            BASE, BASE,
                            color = 'y'
                        )

track_L = patches.Rectangle(    ( -WIDTH/2 - BASE/2 - WIDTH/2 , -LENGTH/2 ),
                                WIDTH, LENGTH,
                                color = '0.5'
                            )

track_R = patches.Rectangle(    ( -WIDTH/2 + BASE/2 + WIDTH/2 , -LENGTH/2 ),
                                 WIDTH, LENGTH,
                                 color = '0.5'
                            )

arrow = patches.Arrow(  0, -BASE/4,
                        0, BASE/2,
                        ARROW_WIDTH,
                        color = 'b'
                    )

#-- Figure Motion
def displacePatch( rect, x, y, ang ):
        #Rotate
    rot = mpl.transforms.Affine2D().rotate( ang )
        #Translate
    trans = mpl.transforms.Affine2D().translate( x, y )

        #Apply 
    rect.set_transform( rot + trans + axes.transData )

def displaceTank( x, y, ang ):
    displacePatch( arrow,   x,  y,  ang )
    displacePatch( body,    x,  y,  ang )
    displacePatch( track_L, x,  y,  ang )
    displacePatch( track_R, x,  y,  ang )

#-- Animation
def init():
    axes.add_patch( body )
    axes.add_patch( track_L )
    axes.add_patch( track_R )
    axes.add_patch( arrow )
	
    return body, track_L, track_R, arrow

def animate(t):
    displaceTank( x[t], y[t], ang[t] )
    return body, track_L, track_R, arrow

anim = animation.FuncAnimation( fig,
                                animate,
                                init_func = init,
                                frames = STEPS,
                                interval = 0.25,
                                blit = True
                                )

fig.show()

#-- Save animation as video [Remove comment to enable]
#anim.save( "tank_path.mp4", fps = 60 )  
